tiny16 Assembler Specification
==============================

SOURCE
------

- One instruction per line
- Case-insensitive
- Leading/trailing whitespace ignored
- Empty lines ignored

COMMENTS
--------

- `;` starts a comment
- Everything after `;` is ignored

LABELS
------

- Defined as `name:`
- Refer to the address of the next instruction
- Must be unique

REGISTERS
---------

- R0–R7
- Case-insensitive
- R6:R7 form ADDR for indirect memory access
- Assembler does not encode ADDR explicitly

NUMBERS
-------

- Decimal: 42
- Hex: 0x2A
- Binary: 0b101010
- No signed values
- Labels may be used where numbers are accepted

SECTIONS
--------

- section .code : instructions go here
- section .data : data definitions go here
- Default section is .code if not specified
- Labels in each section resolve to their respective memory addresses

PSEUDO-INSTRUCTIONS
-------------------

TIMES (Repeat)
    - Works in both .code and .data sections
    - Syntax: TIMES count instruction
    - Repeats the following instruction count times
    - Useful for shifts, increments, and buffer allocation

Code Section Examples:
    TIMES 4 SHR R0        ; Shift right 4 times (divide by 16)
    TIMES 8 SHL R1        ; Shift left 8 times (multiply by 256)
    TIMES 3 INC R2        ; Increment 3 times

Data Section Examples:
    buffer:  TIMES 256 DB 0         ; 256 bytes of zeros
    pattern: TIMES 10 DB 0xAA       ; 10 bytes of 0xAA
    mixed:   TIMES 4 DB 0xFF, 0x00  ; Repeats pair: FF 00 FF 00 FF 00 FF 00

DATA DIRECTIVES
---------------

DB (Define Byte)
    - Used in .data section
    - Can contain numbers (decimal/hex) or strings
    - Strings are double-quoted: "hello"
    - Escape sequences: \n \t \r \\ \" \0
    - Multiple values separated by commas

Examples:
    msg: DB "Hello World\0"
    values: DB 1, 2, 3, 0xFF
    mixed: DB "A", 65, 0x41

ENCODING
--------

- Every instruction is exactly 3 bytes
- Unused operands are encoded as 0x00
- Format: opcode arg1 arg2
- 16-bit immediates (JMP/JZ/JNZ) are big-endian: [high byte][low byte]
- DB directive bytes are written directly to data section

INSTRUCTIONS
------------

LOADI R, imm8
    -> opcode reg imm8

LOAD R, [PAIR]
STORE R, [PAIR]
    -> opcode arg1 arg2
    -> arg1 encodes: REG(7-5) | MODE(4-3) | PAIR(2-1) | 0
    -> arg2 is offset for OFFSET mode, otherwise 0

    Register Pairs (PAIR field):
      0 = R0:R1
      1 = R2:R3
      2 = R4:R5
      3 = R6:R7

    Addressing Modes (MODE field):
      0 = BASE:   [PAIR]         - direct addressing
      1 = INC:    [PAIR]+        - post-increment
      2 = DEC:    [PAIR]-        - post-decrement
      3 = OFFSET: [PAIR + imm8]  - base + offset

    Examples:
      LOAD  R0, [R6:R7]        -> 0x11 0xC6 0x00  (reg=0, mode=0, pair=3)
      STORE R1, [R2:R3]+       -> 0x12 0x2A 0x00  (reg=1, mode=1, pair=1)
      LOAD  R3, [R4:R5 + 10]   -> 0x11 0x7C 0x0A  (reg=3, mode=3, pair=2)

ADD R1, R2
SUB R1, R2
AND R1, R2
OR  R1, R2
XOR R1, R2
CMP R1, R2
    -> opcode R1 R2

INC R
DEC R
SHL R
SHR R
    -> opcode R 0

PUSH R
POP R
    -> opcode R 0

MOVSPR PAIR
    -> opcode pair_id 0
    -> Move stack pointer to register pair (PAIR = SP)
    -> pair_id: 0=R0:R1, 1=R2:R3, 2=R4:R5, 3=R6:R7

MOVRSP PAIR
    -> opcode pair_id 0
    -> Move register pair to stack pointer (SP = PAIR)
    -> pair_id: 0=R0:R1, 1=R2:R3, 2=R4:R5, 3=R6:R7

JMP addr16 | label
JZ  addr16 | label
JNZ addr16 | label
JC  addr16 | label
JNC addr16 | label
    -> opcode hi lo

CALL addr16 | label
    -> opcode hi lo
    -> pushes return address and jumps to subroutine

RET
    -> opcode 0 0
    -> pops return address and returns from subroutine

HALT
    -> opcode 0 0

DB value1, value2, ...
    -> (data section only)
    -> writes bytes directly to data section

ASSEMBLY PASSES
---------------

Pass 1:
- Remove comments
- Track section directives
- Collect labels (both code and data labels)
- Compute instruction addresses (code at 0x0010+, data at 0x4000+)
- Parse TIMES prefix and multiply instruction count accordingly
- Parse DB directives and accumulate data bytes

Pass 2:
- Encode instructions in code section
- Handle TIMES by emitting instruction multiple times
- Resolve labels to addresses
- Emit bytecode
- Output file signature (16 bytes)
- Output code section
- Pad to data section boundary (0x4000)
- Output data section if present

ERRORS
------

Assembly fails on:
- Unknown instruction
- Invalid register
- Invalid number
- Immediate out of range
- Undefined or duplicate label
- TIMES with invalid count

OUTPUT
------

Binary file with the following structure:

File Signature (16 bytes at 0x0000-0x000F):
- Bytes 0-3:   Magic number ('T', '1', '6', 0x00)
- Bytes 4-5:   Version (major, minor)
- Bytes 6-7:   Entrypoint address (big-endian, typically 0x0010)
- Bytes 8-15:  Reserved (zeros)

Code Section (starts at 0x0010):
- Instructions encoded as 3-byte sequences
- Ends at 0x3FFF (max ~16KB)

Data Section (starts at 0x4000):
- Padded with zeros from end of code to 0x4000
- DB directives output here
- Can extend to 0x791F to initialize graphics memory:
  - 0x4000-0x4FFF: User data (4KB)
  - 0x5000-0x6FFF: Tile data (8KB, 256 tiles × 32 bytes)
  - 0x7000-0x73FF: Tilemap (1KB)
  - 0x7400-0x77FF: Attrmap (1KB)
  - 0x7800-0x78FF: OAM (256 bytes, 64 sprites × 4 bytes)
  - 0x7900-0x791F: Palette (32 bytes, 16 colors × 2 bytes)

EXAMPLES
--------

Basic program with sections:

    section .code

    LOADI R0, 42
    HALT

    section .data

    value: DB 255

Subroutine example:

    section .code

    START:
        LOADI R0, 5
        LOADI R1, 3
        CALL  ADD_FN
        HALT

    ADD_FN:
        ADD   R0, R1
        RET

Using TIMES for efficient shifts:

    section .code

    START:
        LOADI R0, 128
        TIMES 4 SHR R0    ; R0 = 128 >> 4 = 8 (divide by 16)
        HALT

Defining graphics data directly:

    section .data

    ; User data at 0x4000
    state: DB 0

    ; Pad to tile memory at 0x5000
           TIMES 4095 DB 0

    ; Define an 8x8 tile (32 bytes)
    tile0: DB 0x01, 0x11, 0x11, 0x10  ; Row 0
           DB 0x12, 0x22, 0x22, 0x21  ; Row 1
           ; ... remaining rows ...

    ; Pad to OAM at 0x7800
           TIMES 10208 DB 0

    ; Initialize all 64 sprites as hidden (Y = 0xFF)
    oam:   TIMES 64 DB 0xFF, 0x00, 0x00, 0x00

    ; Palette at 0x7900
    palette:
           DB 0x03, 0x00  ; Color 0: dark blue
           DB 0x1F, 0x00  ; Color 1: blue
           DB 0xFC, 0x00  ; Color 2: yellow
           DB 0x00, 0x00  ; Color 3: black

String data:

    section .data

    msg:    DB "Hello World\0"
    count:  DB 12

Mixed data types:

    section .data

    header: DB 0xFF, 0xFE, "ID"
    values: DB 1, 2, 3, 4

NON-GOALS
---------

- No macros
- No includes
- No expressions (e.g., TIMES 4*2 DB 0)
- No linking or relocation

DESIGN RULE
-----------

- The assembler performs no semantic analysis.
- It translates text to bytes exactly as defined by the tiny16 ISA.
