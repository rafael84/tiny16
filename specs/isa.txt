tiny16 ISA
==========


CPU
---

- 8-bit registers: R0–R7
- R6:R7 form a 16-bit address:
  ADDR = (R6 << 8) | R7
- PC: 16-bit
- SP: 16-bit
- Flags: Z, C
- 1 tick = 1 instruction


REGISTERS
---------

R0–R5 : general purpose (8-bit)
R6    : address high byte
R7    : address low byte

PC    : program counter (16-bit)
SP    : stack pointer (16-bit)


FLAGS
-----

Z = 1 if result == 0
C = carry (ADD) or borrow (SUB)

Flags updated by:
- ADD  : Z, C
- SUB  : Z, C
- INC  : Z, C (clears C)
- DEC  : Z, C (clears C)
- AND  : Z, C (clears C)
- OR   : Z, C (clears C)
- XOR  : Z, C (clears C)
- SHL  : Z, C
- SHR  : Z, C

Other instructions do not modify flags.


MEMORY
------

- 16-bit address space
- 64 KB total (0x0000–0xFFFF), shared by code, data, stack, and MMIO.

Layout:
0x0000-0x000F  file signature (magic, version, entrypoint)
0x0010–0x1FFF  code (8176 bytes)
0x2000–0x3FFF  data (8192 bytes)
0x4000–0x7FFF  extended / reserved (16KB)
0x8000–0xBEFF  stack (grows down, ~16KB)
0xBF00–0xBFFF  MMIO control registers (256 bytes)
0xC000–0xFFFF  framebuffer (16,384 bytes = 128×128)


INSTRUCTION FORMAT
------------------

All instructions are 3 bytes:

[ opcode ][ arg1 ][ arg2 ]

- Addresses (JMP, JZ, JNZ) are 16-bit big-endian: [high byte][low byte]
- Immediates (LOADI) are 8-bit
- PC += 3 unless modified by jump


INSTRUCTIONS
------------

0x10  LOADI R, imm8
      R = imm8

0x11  LOAD R
      R = MEM[R6:R7]

0x12  STORE R
      MEM[R6:R7] = R

0x13  MOV R1, R2
      R1 = R2

0x20  ADD R1, R2
      R1 = (R1 + R2) & 0xFF

0x21  SUB R1, R2
      R1 = (R1 - R2) & 0xFF

0x22  INC R
      R = (R + 1) & 0xFF

0x23  DEC R
      R = (R - 1) & 0xFF

0x24  AND R1, R2
      R1 = R1 & R2

0x25  OR R1, R2
      R1 = R1 | R2

0x26  XOR R1, R2
      R1 = R1 ^ R2

0x29  SHL R
      R = R * 2

0x2A  SHR R
      R = R / 2

0x2C  PUSH R
      MEM[SP] = R; SP--

0x2D  POP R
      SP++; R = MEM[SP]

0x30  JMP addr16
      PC = addr16

0x31  JZ addr16
      if Z == 1: PC = addr16

0x32  JNZ addr16
      if Z == 0: PC = addr16

0xFF  HALT
      stop execution


ADDRESSING
----------

- LOAD / STORE use ADDR = (R6 << 8) | R7
- arg2 ignored for LOAD / STORE
- LOAD / STORE do not affect flags


MMIO
----

MMIO Control Registers (0xBF00-0xBFFF):

TODO: Input (0xBF00-0xBF0F):
- 0xBF00 : KEYS_STATE      (R ) gamepad/keyboard state (8 bits)
- 0xBF01 : KEYS_PRESSED    (R ) edge detection (cleared on read)
- 0xBF02 : MOUSE_X         (R ) mouse X position (0-127)
- 0xBF03 : MOUSE_Y         (R ) mouse Y position (0-127)
- 0xBF04 : MOUSE_BUTTONS   (R ) mouse button state

Timers (0xBF20-0xBF2F):
- 0xBF20 : TICK_LOW        (R ) CPU instruction counter low byte
- 0xBF21 : TICK_HIGH       (R ) CPU instruction counter high byte
- 0xBF22 : FRAME_COUNT     (R ) frame counter (60Hz)
- 0xBF23 : VSYNC           (RW) frame synchronization
                                Write 1 to signal frame complete (triggers back buffer swap)
                                Read returns 0 after swap is processed

TODO: Random (0xBF30-0xBF3F):
- 0xBF30 : RNG_VALUE       (R ) read random byte
- 0xBF31 : RNG_SEED_LOW    (W ) set seed low byte
- 0xBF32 : RNG_SEED_HIGH   (W ) set seed high byte

TODO: System (0xBFF0-0xBFFF):
- 0xBFF0 : SYS_CONTROL     (RW) system control flags

Framebuffer (0xC000-0xFFFF):
- Base: 0xC000
- Size: 128 x 128 pixels
- Format: 1 byte per pixel (RGB332)
- addr = 0xC000 + (y << 7) + x
- Pure video RAM (no control registers)


EXAMPLES
--------

Copy register:
    MOV R1, R0        ; R1 = R0

Read from address 0xBF22:
    LOADI R6, 0xBF
    LOADI R7, 0x22
    LOAD  R0          ; R0 = memory[0xBF22]

Signal frame complete:
    LOADI R6, 0xBF
    LOADI R7, 0x23
    LOADI R0, 1
    STORE R0          ; memory[0xBF23] = 1


RESET
-----

PC = 0x0010
SP = 0xBEFF
R0–R7 = 0
Z = 0
C = 0


UNDEFINED
---------

- Unknown opcode
- Invalid memory access
- Undefined MMIO access
