tiny16 ISA
==========


CPU
---

- 8-bit registers: R0–R7
- R6:R7 form a 16-bit address:
  ADDR = (R6 << 8) | R7
- PC: 16-bit
- SP: 16-bit
- Flags: Z, C
- 1 tick = 1 instruction


REGISTERS
---------

R0–R5 : general purpose (8-bit)
R6    : address high byte
R7    : address low byte

PC    : program counter (16-bit)
SP    : stack pointer (16-bit)


FLAGS
-----

Z = 1 if result == 0
C = carry (ADD) or borrow (SUB)

Flags updated by:
- ADD  : Z, C
- SUB  : Z, C
- ADC  : Z, C
- SBC  : Z, C
- INC  : Z, C (clears C)
- DEC  : Z, C (clears C)
- AND  : Z, C (clears C)
- OR   : Z, C (clears C)
- XOR  : Z, C (clears C)
- CMP  : Z, C
- SHL  : Z, C
- SHR  : Z, C

Other instructions do not modify flags.


MEMORY
------

- 16-bit address space
- 64 KB total (0x0000–0xFFFF), shared by code, data, stack, and MMIO.

Layout:
0x0000-0x000F  file signature (magic, version, entrypoint)
0x0010–0x1FFF  code (8176 bytes)
0x2000–0x3FFF  data (8192 bytes)
0x4000–0x7FFF  extended / reserved (16KB)
0x8000–0xBEFF  stack (grows down, ~16KB)
0xBF00–0xBFFF  MMIO control registers (256 bytes)
0xC000–0xFFFF  framebuffer (16,384 bytes = 128×128)


INSTRUCTION FORMAT
------------------

All instructions are 3 bytes:

[ opcode ][ arg1 ][ arg2 ]

- Addresses (JMP, JZ, JNZ) are 16-bit big-endian: [high byte][low byte]
- Immediates (LOADI) are 8-bit
- PC += 3 unless modified by jump


INSTRUCTIONS
------------

0x10  LOADI R, imm8
      Load immediate 8-bit value into register.
      R = imm8
      Does not affect flags.

0x11  LOAD R
      Load byte from memory at address formed by R6:R7.
      R = MEM[ADDR], where ADDR = (R6 << 8) | R7
      Does not affect flags.
      Special: Reading from 0xBF01 (KEYS_PRESSED) clears it after read.

0x12  STORE R
      Store register value to memory at address formed by R6:R7.
      MEM[ADDR] = R, where ADDR = (R6 << 8) | R7
      Does not affect flags.
      Cannot write to code segment (0x0010-0x1FFF).

0x13  MOV R1, R2
      Copy value from one register to another.
      R1 = R2
      Does not affect flags.
      R2 remains unchanged.

0x20  ADD R1, R2
      Add two registers, store result in first register.
      R1 = (R1 + R2) & 0xFF
      Sets Z=1 if result is zero, Z=0 otherwise.
      Sets C=1 if addition overflows (result > 255), C=0 otherwise.
      R2 remains unchanged.

0x21  SUB R1, R2
      Subtract second register from first, store result in first register.
      R1 = (R1 - R2) & 0xFF
      Sets Z=1 if result is zero, Z=0 otherwise.
      Sets C=1 if borrow occurs (R1 < R2), C=0 otherwise.
      R2 remains unchanged.

0x22  INC R
      Increment register by 1.
      R = (R + 1) & 0xFF
      Sets Z=1 if result is zero (wraparound from 255), Z=0 otherwise.
      Always clears C flag (C=0).

0x23  DEC R
      Decrement register by 1.
      R = (R - 1) & 0xFF
      Sets Z=1 if result is zero, Z=0 otherwise.
      Always clears C flag (C=0).

0x24  AND R1, R2
      Bitwise AND two registers, store result in first register.
      R1 = R1 & R2
      Sets Z=1 if result is zero, Z=0 otherwise.
      Always clears C flag (C=0).
      R2 remains unchanged.

0x25  OR R1, R2
      Bitwise OR two registers, store result in first register.
      R1 = R1 | R2
      Sets Z=1 if result is zero, Z=0 otherwise.
      Always clears C flag (C=0).
      R2 remains unchanged.

0x26  XOR R1, R2
      Bitwise XOR two registers, store result in first register.
      R1 = R1 ^ R2
      Sets Z=1 if result is zero, Z=0 otherwise.
      Always clears C flag (C=0).
      R2 remains unchanged.
      Note: XOR R, R is a common idiom to zero a register.

0x27  CMP R1, R2
      Compare R1 and R2 by computing R1 - R2, set flags, but don't store result.
      Sets Z=1 if R1 == R2 (result is zero)
      Sets C=1 if R1 < R2 (borrow occurred)
      Sets C=0, Z=0 if R1 > R2
      Does not modify R1 or R2.

0x28  ADC R1, R2
      Add with carry - adds two registers plus carry flag, store result in first register.
      R1 = (R1 + R2 + C) & 0xFF
      Sets Z=1 if result is zero, Z=0 otherwise.
      Sets C=1 if addition overflows (result > 255), C=0 otherwise.
      R2 remains unchanged.
      Useful for multi-byte addition by chaining operations.

0x29  SHL R
      Shift left logical (multiply by 2).
      Shifts all bits left by 1 position, bit 0 becomes 0.
      R = (R << 1) & 0xFF
      Sets C=1 if bit 7 was set before shift (bit shifted out), C=0 otherwise.
      Sets Z=1 if result is zero, Z=0 otherwise.
      Equivalent to multiplying by 2 (with overflow).

0x2A  SHR R
      Shift right logical (divide by 2).
      Shifts all bits right by 1 position, bit 7 becomes 0.
      R = R >> 1
      Sets C=1 if bit 0 was set before shift (bit shifted out), C=0 otherwise.
      Sets Z=1 if result is zero, Z=0 otherwise.
      Equivalent to integer division by 2 (rounding down).

0x2B  SBC R1, R2
      Subtract with carry (borrow) - subtracts second register and carry flag from first.
      R1 = (R1 - R2 - C) & 0xFF
      Sets Z=1 if result is zero, Z=0 otherwise.
      Sets C=1 if borrow occurs (R1 < R2 + C), C=0 otherwise.
      R2 remains unchanged.
      Useful for multi-byte subtraction by chaining operations.

0x2C  PUSH R
      Push register value onto stack.
      MEM[SP] = R; SP = SP - 1
      Stores register at current stack pointer, then decrements SP.
      Does not affect flags.
      Stack overflow occurs if SP goes below 0x8000.

0x2D  POP R
      Pop value from stack into register.
      SP = SP + 1; R = MEM[SP]
      Increments SP first, then loads value into register.
      Does not affect flags.
      Stack underflow occurs if SP goes above 0xBEFF.

0x30  JMP addr16
      Unconditional jump to address.
      PC = addr16
      Always jumps to the specified 16-bit address.
      Does not affect flags or stack.

0x31  JZ addr16
      Jump if zero flag is set.
      if Z == 1: PC = addr16
      Jumps to address if last arithmetic/logic operation resulted in zero.
      If Z == 0, continues to next instruction.
      Does not affect flags.

0x32  JNZ addr16
      Jump if zero flag is clear.
      if Z == 0: PC = addr16
      Jumps to address if last arithmetic/logic operation did not result in zero.
      If Z == 1, continues to next instruction.
      Does not affect flags.

0x33  JC addr16
      Jump if carry flag is set.
      if C == 1: PC = addr16
      Jumps to address if last operation set carry flag (overflow or borrow).
      Useful for multi-byte arithmetic and unsigned comparisons (less than).
      If C == 0, continues to next instruction.
      Does not affect flags.

0x34  JNC addr16
      Jump if carry flag is clear.
      if C == 0: PC = addr16
      Jumps to address if last operation cleared carry flag (no overflow/borrow).
      Useful for multi-byte arithmetic and unsigned comparisons (greater/equal).
      If C == 1, continues to next instruction.
      Does not affect flags.

0x40  CALL addr16
      Call subroutine at address.
      Pushes return address onto stack, then jumps to subroutine.
      PUSH16(PC_next); PC = addr16
      Return address (PC after CALL instruction) is pushed as 16-bit value:
      high byte first, then low byte (big-endian).
      Decrements SP by 2.
      Does not affect flags.
      Use RET to return from subroutine.

0x41  RET
      Return from subroutine.
      Pops 16-bit return address from stack and jumps to it.
      POP16(PC)
      Restores PC from stack (16-bit, big-endian).
      Increments SP by 2.
      Does not affect flags.
      Must match a previous CALL instruction.

0xFF  HALT
      Stop program execution.
      Terminates the program and returns control to emulator.
      Does not affect flags.
      CPU will not execute any further instructions.


ADDRESSING
----------

- LOAD / STORE use ADDR = (R6 << 8) | R7
- arg2 ignored for LOAD / STORE
- LOAD / STORE do not affect flags


MMIO
----

MMIO Control Registers (0xBF00-0xBFFF):

Input (0xBF00-0xBF0F):
- 0xBF00 : KEYS_STATE      (R ) gamepad/keyboard state (8 bits)
                                bit 7: Down,  bit 6: Up,    bit 5: Left,  bit 4: Right
                                bit 3: B,     bit 2: A,     bit 1: Start, bit 0: Select
- 0xBF01 : KEYS_PRESSED    (R ) edge detection (newly pressed keys, cleared on read)
                                Same bit layout as KEYS_STATE
                                Use for actions that trigger once per press
- 0xBF02 : MOUSE_X         (R ) mouse X position (0-127)
- 0xBF03 : MOUSE_Y         (R ) mouse Y position (0-127)
- 0xBF04 : MOUSE_BUTTONS   (R ) mouse button state
                                bit 0: left, bit 1: right, bit 2: middle

Timers (0xBF20-0xBF2F):
- 0xBF20 : TICK_LOW        (R ) CPU instruction counter low byte
- 0xBF21 : TICK_HIGH       (R ) CPU instruction counter high byte
- 0xBF22 : FRAME_COUNT     (R ) frame counter (60Hz)
- 0xBF23 : VSYNC           (RW) frame synchronization
                                Write 1 to signal frame complete (triggers back buffer swap)
                                Read returns 0 after swap is processed

TODO: Random (0xBF30-0xBF3F):
- 0xBF30 : RNG_VALUE       (R ) read random byte
- 0xBF31 : RNG_SEED_LOW    (W ) set seed low byte
- 0xBF32 : RNG_SEED_HIGH   (W ) set seed high byte

TODO: System (0xBFF0-0xBFFF):
- 0xBFF0 : SYS_CONTROL     (RW) system control flags

Framebuffer (0xC000-0xFFFF):
- Base: 0xC000
- Size: 128 x 128 pixels
- Format: 1 byte per pixel (RGB332)
- addr = 0xC000 + (y << 7) + x
- Pure video RAM (no control registers)


EXAMPLES
--------

Simple arithmetic:
        LOADI R0, 42      ; Load immediate value
        LOADI R1, 10      ; Load another value
        ADD   R0, R1      ; R0 = R0 + R1 (R0 = 52)
        SHL   R0          ; R0 = R0 * 2 (R0 = 104)
        MOV   R2, R0      ; Copy R0 to R2
        HALT              ; Stop execution

Copy register:
        MOV R1, R0        ; R1 = R0

Read from address 0xBF22:
        LOADI R6, 0xBF
        LOADI R7, 0x22
        LOAD  R0          ; R0 = memory[0xBF22]

Signal frame complete:
        LOADI R6, 0xBF
        LOADI R7, 0x23
        LOADI R0, 1
        STORE R0          ; memory[0xBF23] = 1

Read keyboard input:
        LOADI R6, 0xBF
        LOADI R7, 0x00
        LOAD  R0          ; R0 = KEYS_STATE
        LOADI R1, 0x40    ; bit 6 = Up
        AND   R0, R1      ; Check if Up is pressed
        JZ    NOT_UP      ; Jump if Up not pressed
        ; ... handle Up press ...

Read button press (edge detection):
        LOADI R6, 0xBF
        LOADI R7, 0x01
        LOAD  R0          ; R0 = KEYS_PRESSED (auto-clears on read)
        LOADI R1, 0x04    ; bit 2 = A button
        AND   R0, R1      ; Check if A was just pressed
        JZ    NOT_A       ; Jump if A not pressed this frame
        ; ... handle A press (fires once) ...

Read mouse position and button:
        LOADI R6, 0xBF
        LOADI R7, 0x02
        LOAD  R0          ; R0 = mouse X (0-127)
        LOADI R7, 0x03
        LOAD  R1          ; R1 = mouse Y (0-127)
        LOADI R7, 0x04
        LOAD  R2          ; R2 = mouse buttons
        LOADI R3, 0x01    ; bit 0 = left button
        AND   R2, R3
        JZ    NOT_CLICKED ; Jump if not clicked
        ; ... handle mouse click at (R0, R1) ...

Compare two values and branch:
        LOADI R0, 42
        LOADI R1, 30
        CMP   R0, R1      ; Compare R0 - R1, set Z and C flags
        JZ    EQUAL       ; If Z=1: R0 == R1
        JC    LESS        ; If C=1: R0 < R1 (borrow occurred)
        ; Otherwise: R0 > R1 (fall through)
    GREATER:
        LOADI R2, 100     ; R0 > R1
        JMP   END
    LESS:
        LOADI R2, 0       ; R0 < R1
        JMP   END
    EQUAL:
        LOADI R2, 50      ; R0 == R1
        JMP   END
    END:
        HALT

Multi-byte addition using carry:
        LOADI R0, 200     ; Low byte first value
        LOADI R1, 100     ; Low byte second value
        ADD   R0, R1      ; R0 = low byte result, sets C if overflow
        JNC   NO_CARRY
        ; Handle carry
        LOADI R2, 1       ; High byte gets +1
        JMP   DONE
    NO_CARRY:
        LOADI R2, 0       ; High byte gets 0
    DONE:
        ; R2:R0 now holds 16-bit result

Multi-byte addition using ADC (cleaner):
        ; Add two 16-bit numbers: R6:R7 = 0x01FF, R0:R1 = 0x0002
        LOADI R6, 0x01    ; High byte first value
        LOADI R7, 0xFF    ; Low byte first value
        LOADI R0, 0x00    ; High byte second value
        LOADI R1, 0x02    ; Low byte second value
        ADD   R7, R1      ; Add low bytes, sets C if overflow
        ADC   R6, R0      ; Add high bytes + carry
        ; R6:R7 now holds 0x0201 (513)

Multi-byte subtraction using SBC:
        ; Subtract two 16-bit numbers: R6:R7 = 0x0201, R0:R1 = 0x00FF
        LOADI R6, 0x02    ; High byte first value
        LOADI R7, 0x01    ; Low byte first value
        LOADI R0, 0x00    ; High byte second value
        LOADI R1, 0xFF    ; Low byte second value
        SUB   R7, R1      ; Subtract low bytes, sets C if borrow
        SBC   R6, R0      ; Subtract high bytes - borrow
        ; R6:R7 now holds 0x0102 (258)

Call a subroutine:
        LOADI R0, 5
        LOADI R1, 3
        CALL  ADD_FN      ; Call function at ADD_FN
        HALT
    ADD_FN:
        ADD   R0, R1      ; R0 = R0 + R1
        RET               ; Return to caller

Nested subroutine calls:
        CALL  OUTER       ; Call outer function
        HALT
    OUTER:
        LOADI R0, 10
        CALL  INNER       ; Nested call
        RET
    INNER:
        INC   R0          ; R0 = 11
        RET

Preserve registers in subroutine:
        LOADI R0, 5
        LOADI R1, 10
        CALL  FUNC
        ADD   R0, R1      ; R1 still = 10
        HALT
    FUNC:
        PUSH  R1          ; Save R1
        LOADI R1, 99      ; Use R1 temporarily
        ADD   R0, R1      ; R0 = 5 + 99 = 104
        POP   R1          ; Restore R1 = 10
        RET


RESET
-----

PC = 0x0010
SP = 0xBEFF
R0–R7 = 0
Z = 0
C = 0


UNDEFINED
---------

- Unknown opcode
- Invalid memory access
- Undefined MMIO access
