tiny16 ISA
==========


CPU
---

- 8-bit registers: R0–R7
- R6:R7 form a 16-bit address:
  ADDR = (R6 << 8) | R7
- PC: 16-bit
- SP: 16-bit
- Flags: Z, C
- 1 tick = 1 instruction


REGISTERS
---------

R0–R5 : general purpose (8-bit)
R6    : address high byte
R7    : address low byte

PC    : program counter (16-bit)
SP    : stack pointer (16-bit)


FLAGS
-----

Z = 1 if result == 0
C = carry (ADD) or borrow (SUB)

Flags updated by:
- ADD  : Z, C
- SUB  : Z, C
- INC  : Z, C (clears C)
- DEC  : Z, C (clears C)
- AND  : Z, C (clears C)
- OR   : Z, C (clears C)
- XOR  : Z, C (clears C)
- SHL  : Z, C
- SHR  : Z, C

Other instructions do not modify flags.


MEMORY
------

- 16-bit address space
- 64 KB total (0x0000–0xFFFF), shared by code, data, stack, and MMIO.

Layout:
0x0000-0x000F  file signature (magic, version, entrypoint)
0x0010–0x1FFF  code (8176 bytes)
0x2000–0x3FFF  data (8192 bytes)
0x4000–0x7FFF  extended / reserved (16KB)
0x8000–0xBEFF  stack (grows down, ~16KB)
0xBF00–0xBFFF  MMIO control registers (256 bytes)
0xC000–0xFFFF  framebuffer (16,384 bytes = 128×128)


INSTRUCTION FORMAT
------------------

All instructions are 3 bytes:

[ opcode ][ arg1 ][ arg2 ]

- Addresses (JMP, JZ, JNZ) are 16-bit big-endian: [high byte][low byte]
- Immediates (LOADI) are 8-bit
- PC += 3 unless modified by jump


INSTRUCTIONS
------------

0x10  LOADI R, imm8
      R = imm8

0x11  LOAD R
      R = MEM[R6:R7]

0x12  STORE R
      MEM[R6:R7] = R

0x13  MOV R1, R2
      R1 = R2

0x20  ADD R1, R2
      R1 = (R1 + R2) & 0xFF

0x21  SUB R1, R2
      R1 = (R1 - R2) & 0xFF

0x22  INC R
      R = (R + 1) & 0xFF

0x23  DEC R
      R = (R - 1) & 0xFF

0x24  AND R1, R2
      R1 = R1 & R2

0x25  OR R1, R2
      R1 = R1 | R2

0x26  XOR R1, R2
      R1 = R1 ^ R2

0x29  SHL R
      R = R * 2

0x2A  SHR R
      R = R / 2

0x2C  PUSH R
      MEM[SP] = R; SP--

      Push register onto stack.

0x2D  POP R
      SP++; R = MEM[SP]

      Pop from stack into register.

0x30  JMP addr16
      PC = addr16

      Unconditional jump to address.

0x31  JZ addr16
      if Z == 1: PC = addr16

      Jump to address if zero flag is set.

0x32  JNZ addr16
      if Z == 0: PC = addr16

      Jump to address if zero flag is clear.

0x33  JC addr16
      if C == 1: PC = addr16

      Jump to address if carry flag is set.

0x34  JNC addr16
      if C == 0: PC = addr16

      Jump to address if carry flag is clear.

0x40  CALL addr16
      PUSH16(PC); PC = addr16

      Call subroutine at address. Pushes return address (PC after CALL)
      onto stack (16-bit, big-endian: high byte first, then low byte).
      Use RET to return from subroutine.

0x41  RET
      POP16(PC)

      Return from subroutine. Pops 16-bit return address from stack
      and jumps to it. Must match a previous CALL instruction.

0xFF  HALT
      stop execution


ADDRESSING
----------

- LOAD / STORE use ADDR = (R6 << 8) | R7
- arg2 ignored for LOAD / STORE
- LOAD / STORE do not affect flags


MMIO
----

MMIO Control Registers (0xBF00-0xBFFF):

Input (0xBF00-0xBF0F):
- 0xBF00 : KEYS_STATE      (R ) gamepad/keyboard state (8 bits)
                                bit 7: Down,  bit 6: Up,    bit 5: Left,  bit 4: Right
                                bit 3: B,     bit 2: A,     bit 1: Start, bit 0: Select
- 0xBF01 : KEYS_PRESSED    (R ) edge detection (newly pressed keys, cleared on read)
                                Same bit layout as KEYS_STATE
                                Use for actions that trigger once per press
- 0xBF02 : MOUSE_X         (R ) mouse X position (0-127)
- 0xBF03 : MOUSE_Y         (R ) mouse Y position (0-127)
- 0xBF04 : MOUSE_BUTTONS   (R ) mouse button state
                                bit 0: left, bit 1: right, bit 2: middle

Timers (0xBF20-0xBF2F):
- 0xBF20 : TICK_LOW        (R ) CPU instruction counter low byte
- 0xBF21 : TICK_HIGH       (R ) CPU instruction counter high byte
- 0xBF22 : FRAME_COUNT     (R ) frame counter (60Hz)
- 0xBF23 : VSYNC           (RW) frame synchronization
                                Write 1 to signal frame complete (triggers back buffer swap)
                                Read returns 0 after swap is processed

TODO: Random (0xBF30-0xBF3F):
- 0xBF30 : RNG_VALUE       (R ) read random byte
- 0xBF31 : RNG_SEED_LOW    (W ) set seed low byte
- 0xBF32 : RNG_SEED_HIGH   (W ) set seed high byte

TODO: System (0xBFF0-0xBFFF):
- 0xBFF0 : SYS_CONTROL     (RW) system control flags

Framebuffer (0xC000-0xFFFF):
- Base: 0xC000
- Size: 128 x 128 pixels
- Format: 1 byte per pixel (RGB332)
- addr = 0xC000 + (y << 7) + x
- Pure video RAM (no control registers)


EXAMPLES
--------

Copy register:
    MOV R1, R0        ; R1 = R0

Read from address 0xBF22:
    LOADI R6, 0xBF
    LOADI R7, 0x22
    LOAD  R0          ; R0 = memory[0xBF22]

Signal frame complete:
    LOADI R6, 0xBF
    LOADI R7, 0x23
    LOADI R0, 1
    STORE R0          ; memory[0xBF23] = 1

Read keyboard input:
    LOADI R6, 0xBF
    LOADI R7, 0x00
    LOAD  R0          ; R0 = KEYS_STATE
    LOADI R1, 0x40    ; bit 6 = Up
    AND   R0, R1      ; Check if Up is pressed
    JZ    NOT_UP      ; Jump if Up not pressed
    ; ... handle Up press ...

Read button press (edge detection):
    LOADI R6, 0xBF
    LOADI R7, 0x01
    LOAD  R0          ; R0 = KEYS_PRESSED (auto-clears on read)
    LOADI R1, 0x04    ; bit 2 = A button
    AND   R0, R1      ; Check if A was just pressed
    JZ    NOT_A       ; Jump if A not pressed this frame
    ; ... handle A press (fires once) ...

Read mouse position:
    LOADI R6, 0xBF
    LOADI R7, 0x02
    LOAD  R0          ; R0 = mouse X (0-127)
    LOADI R7, 0x03
    LOAD  R1          ; R1 = mouse Y (0-127)

Multi-byte addition using carry:
    LOADI R0, 200     ; Low byte first value
    LOADI R1, 100     ; Low byte second value
    ADD   R0, R1      ; R0 = low byte result, sets C if overflow
    JNC   NO_CARRY
    ; Handle carry
    LOADI R2, 1       ; High byte gets +1
    JMP   DONE
NO_CARRY:
    LOADI R2, 0       ; High byte gets 0
DONE:
    ; R2:R0 now holds 16-bit result

Call a subroutine:
    LOADI R0, 5
    LOADI R1, 3
    CALL  ADD_FN      ; Call function at ADD_FN
    HALT

ADD_FN:
    ADD   R0, R1      ; R0 = R0 + R1
    RET               ; Return to caller

Nested subroutine calls:
    CALL  OUTER       ; Call outer function
    HALT

OUTER:
    LOADI R0, 10
    CALL  INNER       ; Nested call
    RET

INNER:
    INC   R0          ; R0 = 11
    RET

Preserve registers in subroutine:
    LOADI R0, 5
    LOADI R1, 10
    CALL  FUNC
    ADD   R0, R1      ; R1 still = 10
    HALT

FUNC:
    PUSH  R1          ; Save R1
    LOADI R1, 99      ; Use R1 temporarily
    ADD   R0, R1      ; R0 = 5 + 99 = 104
    POP   R1          ; Restore R1 = 10
    RET


RESET
-----

PC = 0x0010
SP = 0xBEFF
R0–R7 = 0
Z = 0
C = 0


UNDEFINED
---------

- Unknown opcode
- Invalid memory access
- Undefined MMIO access
